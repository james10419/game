<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D 사이버펑크 슈터</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&family=Orbitron:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0a0a1a; /* Dark blue background */
            font-family: 'Orbitron', sans-serif; /* Cyberpunk font */
            color: #00ffff; /* Cyan text color */
            cursor: crosshair; /* Crosshair cursor */
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        /* HUD Styling */
        .hud {
            position: absolute;
            padding: 7px 10px; /* Smaller padding */
            background-color: rgba(10, 20, 40, 0.8); /* Semi-transparent dark blue */
            border: 1px solid #00ffff; /* Cyan border */
            border-radius: 3px; /* Slightly rounded corners */
            font-size: 12px; /* Smaller font size */
            text-shadow: 0 0 3px #00ffff, 0 0 5px #00ffff; /* Cyan glow */
            box-shadow: 0 0 8px rgba(0, 255, 255, 0.5); /* Outer glow */
        }
        #score { /* Score HUD */
            top: 15px;
            left: 15px;
            font-size: 14px; /* Slightly larger font */
        }
        #health { /* Health HUD */
            top: 15px;
            right: 15px;
            color: #ff4500; /* Orange-red color for health */
            text-shadow: 0 0 3px #ff4500, 0 0 5px #ff4500;
            border-color: #ff4500;
            box-shadow: 0 0 8px rgba(255, 69, 0, 0.5);
            font-size: 14px; /* Slightly larger font */
        }
        #ammo { /* Ammo HUD */
            bottom: 15px;
            left: 15px;
        }
        #playerDamageHUD { /* Player Damage HUD */
            bottom: 45px; /* Positioned above ammo */
            left: 15px;
        }
        #roundInfo { /* Round Info HUD */
            top: 50px; /* Positioned below score */
            left: 15px;
        }
        #machineGunInfo { /* Machine Gun HUD */
            top: 95px; /* Positioned below round info */
            left: 15px;
            color: #FF00FF; /* Magenta color */
            text-shadow: 0 0 3px #FF00FF, 0 0 5px #FF00FF;
            border-color: #FF00FF;
            box-shadow: 0 0 8px rgba(255, 0, 255, 0.5);
        }
        #shieldInfo { /* Shield HUD */
            top: 150px; /* Positioned below machine gun */
            left: 15px;
            color: #40C4FF; /* Light blue color */
            text-shadow: 0 0 3px #40C4FF, 0 0 5px #40C4FF;
            border-color: #40C4FF;
            box-shadow: 0 0 8px rgba(64, 196, 255, 0.5);
        }
        #slideJumpInfo { /* Slide Jump HUD */
            top: 200px; /* Positioned below shield */
            left: 15px;
            color: #FFFF00; /* Yellow color */
            text-shadow: 0 0 3px #FFFF00, 0 0 5px #FFFF00;
            border-color: #FFFF00;
            box-shadow: 0 0 8px rgba(255, 255, 0, 0.5);
        }
        #elapsedTimeHUD { /* Elapsed Time HUD */
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            background-color: rgba(10, 20, 40, 0.6);
            border: 1px solid #00ffff;
        }
        /* Message Box Styling */
        #messageBox { /* General message box */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 30px;
            background-color: rgba(0,0,10,0.9); /* Very dark blue, almost opaque */
            border: 2px solid #FF00FF; /* Magenta border */
            border-radius: 5px;
            text-align: center;
            font-size: 24px;
            z-index: 1000;
            display: flex; /* Use flexbox for centering */
            flex-direction: column;
            align-items: center;
            box-shadow: 0 0 20px rgba(255,0,255,0.7); /* Magenta glow */
        }
        #messageText { /* Text within the message box */
            margin-bottom: 20px;
            color: #00FF00; /* Green text */
            text-shadow: 0 0 5px #00FF00;
        }
        /* Temporary Message Styling */
        #roundTransitionMessage, #shieldStatusMessage, #machineGunStatusMessage { /* Round/Shield/MG messages */
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 32px;
            color: #00FF00; /* Green text */
            text-shadow: 0 0 7px #00FF00, 0 0 10px #00FF00; /* Green glow */
            padding: 15px;
            background-color: rgba(0,30,0,0.7); /* Dark green background */
            border-radius: 5px;
            border: 1px solid #00FF00;
            display: none; /* Hidden by default */
            z-index: 1001;
        }
        #tacticalReloadMessage { /* Tactical Reload message */
            position: absolute;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            font-size: 28px;
            color: yellow;
            text-shadow: 0 0 5px yellow, 0 0 8px yellow; /* Yellow glow */
            padding: 10px;
            background-color: rgba(50,50,0,0.7); /* Dark yellow background */
            border-radius: 5px;
            border: 1px solid yellow;
            display: none; /* Hidden by default */
            z-index: 1001;
        }
        /* Damage Indicator Styling */
        .damage-indicator { /* Base style for damage indicators */
            position: absolute;
            top: 30%; /* Position higher on screen */
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Orbitron', sans-serif; /* Use Orbitron font */
            font-weight: 700; /* Bold */
            padding: 15px;
            display: none; /* Hidden by default */
            z-index: 1002;
            text-align: center;
        }
        #criticalHitMessage { /* Critical Hit message */
            font-size: 42px; /* Large font size */
            color: #FF00FF; /* Magenta color */
            text-shadow: 0 0 5px #FF00FF, 0 0 10px #FF00FF, 0 0 15px #FF00FF, 0 0 20px #FFF, 2px 2px 2px #000; /* Intense magenta/white glow with drop shadow */
            animation: criticalHitAnimation 0.7s ease-out forwards;
        }
        #superCriticalHitMessage { /* Super Critical Hit message */
            font-size: 52px; /* Even larger font size */
            color: #FFD700; /* Gold color */
            text-shadow: 0 0 7px #FFD700, 0 0 12px #FFD700, 0 0 18px #FFF, 0 0 25px #FFF, 3px 3px 3px #000; /* Intense gold/white glow with drop shadow */
            animation: superCriticalHitAnimation 1s ease-out forwards; /* Longer animation */
        }

        /* Keyframe Animations for Damage Indicators */
        @keyframes criticalHitAnimation { /* Animation for critical hit */
            0% { transform: translateX(-50%) scale(0.5) rotate(-5deg); opacity: 0; }
            70% { transform: translateX(-50%) scale(1.2) rotate(5deg); opacity: 1; }
            100% { transform: translateX(-50%) scale(1) rotate(0deg); opacity: 1; }
        }
        @keyframes superCriticalHitAnimation { /* Animation for super critical hit */
            0% { transform: translateX(-50%) scale(0.6) rotate(0deg); opacity: 0; }
            25% { transform: translateX(-50%) scale(1.3) rotate(-3deg); opacity: 1; }
            50% { transform: translateX(-50%) scale(1.1) rotate(3deg); opacity: 1; }
            75% { transform: translateX(-50%) scale(1.25) rotate(-2deg); opacity: 1; }
            100% { transform: translateX(-50%) scale(1.15) rotate(0deg); opacity: 1; }
        }


        /* Button Styling */
        .button { /* General button style */
            padding: 12px 25px;
            background-color: #8A2BE2; /* Blue-violet background */
            color: #00ffff; /* Cyan text */
            border: 2px solid #00ffff; /* Cyan border */
            border-radius: 3px;
            cursor: pointer;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            transition: background-color 0.3s ease, transform 0.1s ease, box-shadow 0.3s ease;
            box-shadow: 0 0 10px rgba(0,255,255,0.5); /* Cyan glow */
            text-transform: uppercase;
        }
        .button:hover { /* Button hover effect */
            background-color: #9932CC; /* Darker orchid */
            border-color: #FFF; /* White border */
            box-shadow: 0 0 15px rgba(255,255,255,0.8); /* White glow */
        }
        .button:active { /* Button active (click) effect */
            transform: translateY(2px);
            box-shadow: 0 0 5px rgba(255,255,255,0.5);
        }
        /* Crosshair Styling */
        #crosshair { /* Simple crosshair */
            position: absolute;
            top: 50%;
            left: 50%;
            width: 4px; /* Vertical line width */
            height: 20px; /* Vertical line height */
            background-color: #00ffff; /* Cyan color */
            transform: translate(-50%, -50%);
            border-radius: 1px;
            box-shadow: 0 0 5px #00ffff; /* Cyan glow */
            z-index: 999;
            display: none; /* Hidden initially */
        }
        #crosshair::before { /* Horizontal line of the crosshair */
            content: '';
            position: absolute;
            width: 20px; /* Horizontal line width */
            height: 4px; /* Horizontal line height */
            background-color: #00ffff;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 1px;
            box-shadow: 0 0 5px #00ffff;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="score" class="hud">점수: 0</div>
    <div id="health" class="hud">체력: 100 / 100</div>
    <div id="ammo" class="hud">탄약: 30 / 30</div>
    <div id="playerDamageHUD" class="hud">데미지: 0</div>
    <div id="roundInfo" class="hud">라운드: 1<br>처치 목표: 20</div>
    <div id="machineGunInfo" class="hud">머신건: 준비<br>탄약: -</div>
    <div id="shieldInfo" class="hud">방패: 준비<br>내구도: -</div>
    <div id="slideJumpInfo" class="hud">슬라이딩 점프: 가능</div>
    <div id="elapsedTimeHUD" class="hud">시간: 00:00</div>

    <div id="crosshair"></div>

    <div id="tacticalReloadMessage">전술 재장전!</div>
    <div id="criticalHitMessage" class="damage-indicator">CRITICAL!</div>
    <div id="superCriticalHitMessage" class="damage-indicator">SUPER CRITICAL!</div>
    <div id="roundTransitionMessage"></div>
    <div id="shieldStatusMessage"></div>
    <div id="machineGunStatusMessage"></div> <div id="messageBox">
        <div id="messageText">사이버펑크 슈터</div>
        <button id="startButton" class="button">게임 시작</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

    <script>
        // --- Global Variables ---
        let scene, camera, renderer, controls;
        let playerBoundingBox; // Player collision box
        const playerHeight = 1.8; // Player model height
        const playerRadius = 0.4; // Player model radius
        let walls = []; // Array to store wall objects
        let enemies = []; // Array to store enemy objects
        let enemyBullets = []; // Array to store enemy bullet objects
        let playerBullets = []; // Array to store player bullet objects
        let muzzleSmokeParticles = []; // Array for muzzle smoke effects
        let impactSparks = []; // Array for bullet impact sparks
        let explosionParticles = []; // Array for enemy death explosions

        // Game State Variables
        let gameRunning = false; // Is the game currently active?
        let score = 0; // Player score
        let maxPlayerHealth = 100; // Player maximum health
        let playerHealth = maxPlayerHealth; // Player current health

        // Player Weapon Variables
        const maxPlayerAmmo = 30; // Maximum ammo capacity
        let playerAmmo = maxPlayerAmmo; // Current ammo count
        let isReloading = false; // Is the player currently reloading?
        let isSprinting = false; // Is the player sprinting?

        // Player Movement Variables
        const moveSpeed = 5.0; // Base movement speed
        const sprintMultiplier = 1.3; // Speed multiplier when sprinting
        let currentMoveSpeed = moveSpeed; // Current movement speed
        const defaultFOV = 75; // Default camera field of view
        const sprintFOV = 80; // FOV when sprinting

        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false; // Movement flags
        let canPlayerJump = true; // Can the player jump?
        let playerVelocityY = 0; // Player vertical velocity (for jumping/gravity)
        const playerJumpForce = 7; // Force applied when jumping
        const gravity = -18; // Gravity force

        // Sliding and Slide Jump Variables
        let isSliding = false; // Is the player sliding?
        const slideHeight = playerHeight * 0.6; // Player height when sliding
        const slideFOV = 80; // FOV when sliding
        const slideJumpBoost = 5; // Speed boost after slide jump
        let slideJumpCooldownEndTime = 0; // Timestamp when slide jump cooldown ends
        const slideJumpCooldownDuration = 1500; // Cooldown duration for slide jump (ms)
        let isSlideJumpBoosting = false; // Is the player currently boosted after slide jump?
        let slideJumpBoostEndTime = 0; // Timestamp when slide jump boost ends
        const slideJumpBoostDuration = 5000; // Duration of the slide jump boost (ms)


        // Player Damage Variables
        let currentPlayerDamage = 50; // Current damage dealt by player shots
        let lastDamageUpdateTime = 0; // Timestamp of last damage update
        const damageUpdateInterval = 3000; // Interval to update player damage (ms)

        // Player Gun Model Variables
        let playerGunMesh; // The 3D mesh for the player's gun
        let gunTip; // An invisible object marking the gun's muzzle
        let originalGunMaterial; // Store original gun materials for mode changes

        // Machine Gun Mode Variables
        let isMachineGunModeActive = false; // Is machine gun mode active?
        let machineGunModeEndTime = 0; // Timestamp when machine gun mode ends
        const machineGunModeDuration = 15000; // Duration of machine gun mode (ms)
        const machineGunTotalMaxAmmo = 120; // Max ammo in machine gun mode
        let machineGunCurrentAmmo = 0; // Current ammo in machine gun mode
        let machineGunCooldownEndTime = 0; // Timestamp when machine gun cooldown ends
        const machineGunCooldown = 180000; // Cooldown for machine gun ability (ms)
        let isMouseDown = false; // Is the left mouse button held down?
        let lastMachineGunShootTime = 0; // Timestamp of last machine gun shot
        const machineGunShootInterval = 100; // Firing interval for machine gun (ms)
        let originalCameraPosition = new THREE.Vector3(); // Store original camera offset
        const baseMachineGunDamage = 30;
        let currentMachineGunDamage = baseMachineGunDamage;

        // Shield Ability Variables
        let isShieldActive = false; // Is the shield active?
        let shieldHealth = 0; // Current shield health
        const baseMaxShieldHealth = 15;
        let maxShieldHealth = baseMaxShieldHealth;
        let shieldCooldownEndTime = 0; // Timestamp when shield cooldown ends
        const shieldCooldown = 15000; // Cooldown for shield ability (ms)
        let shieldMesh; // The 3D mesh for the shield effect

        // Audio Variables (Tone.js Synths)
        let shootSound, enemyHitSound, enemyDieSound, playerHurtSound, enemyShootSound,
            ricochetSound, reloadSound, sprintWindSound, roundSuccessSound, gameClearSound,
            jumpSound, landSound, machineGunActivateSound, explosionSound, shieldActivateSound, shieldBreakSound, slideSound, cyberpunkSynth, backgroundMusicLoop;
        let audioContextStarted = false; // Has the Tone.js audio context been started?

        // Round and Game Progression Variables
        let currentRound = 1; // Current game round
        const maxRounds = 5; // Maximum number of rounds
        let enemiesToKillForNextRound = 20; // Number of enemies to kill to advance
        let killedEnemiesThisRound = 0; // Enemies killed in the current round
        let totalKilledEnemies = 0; // Total enemies killed in the game
        let gameStartTime = 0; // Timestamp when the game started

        // Enemy Variables
        const baseEnemySpeedInitial = 1.2; // Base enemy speed in round 1
        let currentGlobalEnemySpeed = baseEnemySpeedInitial; // Current enemy speed for the round
        let baseEnemyBulletSpeed = 15; // Base enemy bullet speed for the round

        // DOM Element References
        const scoreElement = document.getElementById('score');
        const healthElement = document.getElementById('health');
        const ammoElement = document.getElementById('ammo');
        const playerDamageHUDElement = document.getElementById('playerDamageHUD');
        const roundInfoElement = document.getElementById('roundInfo');
        const machineGunInfoElement = document.getElementById('machineGunInfo');
        const shieldInfoElement = document.getElementById('shieldInfo');
        const slideJumpInfoElement = document.getElementById('slideJumpInfo');
        const elapsedTimeHUDElement = document.getElementById('elapsedTimeHUD');
        const messageBoxElement = document.getElementById('messageBox');
        const messageTextElement = document.getElementById('messageText');
        const roundTransitionMessageElement = document.getElementById('roundTransitionMessage');
        const shieldStatusMessageElement = document.getElementById('shieldStatusMessage');
        const machineGunStatusMessageElement = document.getElementById('machineGunStatusMessage');
        const tacticalReloadMessageElement = document.getElementById('tacticalReloadMessage');
        const criticalHitMessageElement = document.getElementById('criticalHitMessage');
        const superCriticalHitMessageElement = document.getElementById('superCriticalHitMessage');
        const startButton = document.getElementById('startButton');
        const crosshairElement = document.getElementById('crosshair');
        const gameCanvas = document.getElementById('gameCanvas');

        // Initial Map Layout (0 = empty, 1 = wall)
        let initialMapLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,1,0,0,0,0,0,1,0,0,0,1],
            [1,0,1,0,1,0,1,1,1,0,1,0,1,0,1],
            [1,0,1,0,0,0,0,0,0,0,0,0,1,0,1],
            [1,0,1,1,1,1,0,1,1,1,1,0,1,0,1],
            [1,0,0,0,0,1,0,0,0,0,1,0,0,0,1],
            [1,1,1,0,1,1,1,0,1,0,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];
        initialMapLayout = initialMapLayout.map(row =>
            row.map(cell => (cell === 2 || cell === 3 ? 0 : cell))
        );

        let currentMapData = [];

        // Constants
        const wallSize = 4;
        const ENEMY_BULLET_SPEED_BASE = 15;
        const PLAYER_BULLET_SPEED = 50;

        // --- Initialization Function ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a2a);
            scene.fog = new THREE.Fog(0x0a0a2a, 15, 65);

            camera = new THREE.PerspectiveCamera(defaultFOV, window.innerWidth / window.innerHeight, 0.1, 1000);

            renderer = new THREE.WebGLRenderer({ canvas: gameCanvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;

            const ambientLight = new THREE.AmbientLight(0x404080, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0x8888ff, 0.4);
            directionalLight.position.set(30, 50, 20);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const neonLight1 = new THREE.PointLight(0x00ffff, 0.8, 40, 2);
            neonLight1.position.set(wallSize * 2.5, wallSize * 0.8, wallSize * 3.5);
            scene.add(neonLight1);
            const neonLight2 = new THREE.PointLight(0xff00ff, 0.8, 40, 2);
            neonLight2.position.set(-wallSize * 3.5, wallSize * 0.8, -wallSize * 2.5);
            scene.add(neonLight2);
            const neonLight3 = new THREE.RectAreaLight(0x00ff00, 5, wallSize*2, wallSize*0.2);
            neonLight3.position.set(0, wallSize * 1.4, -wallSize * 4);
            neonLight3.lookAt(0,0, -wallSize*4);
            scene.add(neonLight3);

            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            controls.getObject().position.y = playerHeight;

            controls.addEventListener('lock', () => {
                messageBoxElement.style.display = 'none';
                crosshairElement.style.display = 'block';
                if (playerGunMesh) playerGunMesh.visible = true;
                if (!gameRunning && (!startButton.textContent.includes("도전") && !startButton.textContent.includes("플레이"))) {
                    startGameFlow();
                } else if (startButton.textContent.includes("계속하기")) {
                     gameRunning = true;
                     if (Tone.Transport.state !== "started" && audioContextStarted) Tone.Transport.start();
                }
            });
            controls.addEventListener('unlock', () => {
                if (playerHealth > 0 && currentRound <= maxRounds) {
                    messageTextElement.textContent = "일시정지됨. 클릭하여 계속하기.";
                    startButton.textContent = "계속하기";
                    messageBoxElement.style.display = 'flex';
                }
                crosshairElement.style.display = 'none';
                if (playerGunMesh) playerGunMesh.visible = false;
                if (shieldMesh) shieldMesh.visible = false;
                gameRunning = false;
                isMouseDown = false;
                if (Tone.Transport.state === "started" && audioContextStarted) Tone.Transport.pause();
            });

            playerBoundingBox = new THREE.Box3();
            generateMapForRound(currentRound);
            const startPos = findStartPosition();
            controls.getObject().position.set(startPos.x, playerHeight, startPos.z);
            originalCameraPosition.copy(camera.position);

            createPlayerGun();
            createShieldMesh();
            updateHUD();
            lastDamageUpdateTime = performance.now();
            updatePlayerDamage();

            window.addEventListener('resize', onWindowResize, false);
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);

            window.addEventListener('mousedown', (event) => {
                if (!controls.isLocked) {
                    controls.lock();
                } else if (gameRunning) {
                    if (event.button === 0) {
                        isMouseDown = true;
                        if (!isMachineGunModeActive) shoot();
                    } else if (event.button === 2) {
                        activateShield();
                    }
                }
            });
             window.addEventListener('mouseup', (event) => {
                if (event.button === 0) {
                    isMouseDown = false;
                }
                if (gameRunning && event.button === 2) {
                    deactivateShield();
                }
            });
            gameCanvas.addEventListener('contextmenu', (event) => event.preventDefault());

            startButton.addEventListener('click', () => {
                if (!audioContextStarted) {
                     initAudio().then(proceedWithStartButton);
                } else {
                    proceedWithStartButton();
                }
            });

            messageTextElement.textContent = "사이버펑크 슈터";
            messageBoxElement.style.display = 'flex';
            messageBoxElement.style.flexDirection = 'column';
            messageBoxElement.style.alignItems = 'center';

            renderer.render(scene, camera);
        }

        function findStartPosition() {
            for (let r = 0; r < currentMapData.length; r++) {
                for (let c = 0; c < currentMapData[r].length; c++) {
                    if (currentMapData[r][c] === 0) {
                        return {
                            x: (c - currentMapData[r].length / 2) * wallSize + wallSize / 2,
                            z: (r - currentMapData.length / 2) * wallSize + wallSize / 2
                        };
                    }
                }
            }
            console.warn("유효한 시작 위치(0)를 찾지 못했습니다. 중앙에 배치합니다.");
            return { x: 0, z: 0 };
        }

        async function initAudio() {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running') {
                await Tone.start();
                audioContextStarted = true;
                console.log("오디오 컨텍스트 시작됨.");
            }

            if (audioContextStarted) {
                shootSound = new Tone.NoiseSynth({ noise: { type: 'pink' }, envelope: { attack: 0.001, decay: 0.05, sustain: 0 }, volume: -15 }).toDestination();
                enemyHitSound = new Tone.Synth({ oscillator: { type: 'square' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }, volume: -18 }).toDestination();
                enemyDieSound = new Tone.NoiseSynth({ noise: {type: "brown"}, envelope: {attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.2}, volume: -12}).toDestination();
                explosionSound = new Tone.NoiseSynth({ noise: {type: "pink", playbackRate: 0.5}, envelope: {attack: 0.005, decay: 0.4, sustain: 0.01, release: 0.3}, volume: -10}).toDestination();
                playerHurtSound = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0 }, volume: -12 }).toDestination();
                enemyShootSound = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.002, decay: 0.06, sustain: 0 }, volume: -20 }).toDestination();
                ricochetSound = new Tone.MetalSynth({ frequency: 100, envelope: { attack: 0.001, decay: 0.1, release: 0.05 }, harmonicity: 3.1, modulationIndex: 16, resonance: 2000, octaves: 0.5, volume: -18 }).toDestination();
                reloadSound = new Tone.MetalSynth({ frequency: 60, envelope: { attack: 0.005, decay: 0.15, release: 0.05 }, harmonicity: 5.1, modulationIndex: 32, resonance: 1000, octaves: 1.5, volume: -12 }).toDestination();
                sprintWindSound = new Tone.NoiseSynth({ noise: { type: 'white', playbackRate: 2 }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.1 }, volume: -28 }).toDestination();
                roundSuccessSound = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 }, volume: -12 }).toDestination();
                gameClearSound = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.3, release: 0.5 }, volume: -10 }).toDestination();
                jumpSound = new Tone.Synth({ oscillator: { type: "triangle" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 }, volume: -18 }).toDestination();
                landSound = new Tone.MembraneSynth({ pitchDecay: 0.01, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 }, volume: -20 }).toDestination();
                machineGunActivateSound = new Tone.Synth({ oscillator: { type: "sawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.1 }, volume: -15 }).toDestination();
                shieldActivateSound = new Tone.Synth({ oscillator: { type: "sine" }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.1 }, volume: -15 }).toDestination();
                shieldBreakSound = new Tone.NoiseSynth({ noise: { type: "white" }, envelope: { attack: 0.001, decay: 0.2, sustain: 0 }, volume: -12 }).toDestination();
                slideSound = new Tone.NoiseSynth({ noise: { type: 'white', playbackRate: 0.8 }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.05, release: 0.1 }, volume: -22 }).toDestination();

                cyberpunkSynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: "fatsawtooth", count: 3, spread: 30 },
                    envelope: { attack: 0.01, decay: 1.5, sustain: 0.3, release: 1 },
                    volume: -22,
                }).toDestination();
                cyberpunkSynth.set({
                    "filter" : { "type" : "lowpass", "frequency": 1500, "Q": 2 },
                    "filterEnvelope" : { "attack" : 0.5, "decay" : 1, "sustain" : 0.1, "release" : 1.5, "baseFrequency" : 300, "octaves" : 3 }
                });
                const cyberpunkNotes = [
                    ["C2", "G2", "A#2"], null, ["F2", "C3"], null,
                    ["G#2", "D#3"], null, ["D2", "A2"], null
                ];
                backgroundMusicLoop = new Tone.Sequence((time, noteGroup) => {
                    if (noteGroup) cyberpunkSynth.triggerAttackRelease(noteGroup, "2n", time);
                }, cyberpunkNotes, "1n").start(0);
                backgroundMusicLoop.loop = true;
                Tone.Transport.bpm.value = 90;

                try {
                    await Tone.loaded();
                    console.log("모든 사운드 로드 완료");
                } catch (error) {
                    console.error("사운드 로딩 중 오류 발생:", error);
                }
            } else {
                console.warn("Tone.js가 로드되지 않았거나 오디오 컨텍스트 시작에 실패했습니다. 사운드 효과가 비활성화됩니다.");
            }
        }

        function proceedWithStartButton() {
            if ((playerHealth <= 0 || currentRound > maxRounds) && (startButton.textContent.includes("도전") || startButton.textContent.includes("플레이") )) {
                resetGameFull();
            }
            controls.lock();
        }

        function startGameFlow() {
            if (!gameStartTime) gameStartTime = performance.now();
            if (Tone.Transport.state !== "started" && audioContextStarted) {
                Tone.Transport.start();
            }
            gameRunning = true;
            lastDamageUpdateTime = performance.now();
            updatePlayerDamage();
            startNewRound();
            animate();
        }

        function startNewRound() {
            if (currentRound > 1) {
                maxPlayerHealth = Math.min(200, maxPlayerHealth + 20);
                maxShieldHealth = Math.floor(baseMaxShieldHealth * (1 + (currentRound - 1) * 0.15));
                currentMachineGunDamage = Math.floor(baseMachineGunDamage * (1 + (currentRound - 1) * 0.10));
            } else {
                maxPlayerHealth = 100;
                maxShieldHealth = baseMaxShieldHealth;
                currentMachineGunDamage = baseMachineGunDamage;
            }
            playerHealth = maxPlayerHealth;

            isReloading = false;
            isMachineGunModeActive = false;
            isShieldActive = false;
            if (shieldMesh) shieldMesh.visible = false;


            walls.forEach(wall => scene.remove(wall)); walls = [];
            enemies.forEach(enemy => scene.remove(enemy)); enemies = [];
            enemyBullets.forEach(bullet => scene.remove(bullet)); enemyBullets = [];
            playerBullets.forEach(bullet => scene.remove(bullet)); playerBullets = [];
            muzzleSmokeParticles.forEach(p => scene.remove(p)); muzzleSmokeParticles = [];
            impactSparks.forEach(p => scene.remove(p)); impactSparks = [];
            explosionParticles.forEach(p => scene.remove(p)); explosionParticles = [];

            generateMapForRound(currentRound);
            createEnvironmentFromMapData();

            killedEnemiesThisRound = 0;
            if (currentRound > 1) {
                 enemiesToKillForNextRound = Math.max(enemiesToKillForNextRound + 5, Math.floor(enemiesToKillForNextRound * 1.3));
            } else {
                enemiesToKillForNextRound = 20;
            }

            currentGlobalEnemySpeed = baseEnemySpeedInitial * (1 + (currentRound - 1) * 0.15);
            const bulletSpeedMultiplier = 1 + (currentRound - 1) * 0.25;
            baseEnemyBulletSpeed = ENEMY_BULLET_SPEED_BASE * bulletSpeedMultiplier;

            spawnEnemiesForRound(enemiesToKillForNextRound + Math.floor(Math.random() * 11));
            updateHUD();
        }

        function generateMapForRound(round) {
            currentMapData = JSON.parse(JSON.stringify(initialMapLayout));
            const changes = Math.min(round * 3, 15);
            let attempts = 0;
            for (let i = 0; i < changes && attempts < 100; attempts++) {
                const r = Math.floor(Math.random() * (currentMapData.length - 2)) + 1;
                const c = Math.floor(Math.random() * (currentMapData[0].length - 2)) + 1;
                if (currentMapData[r][c] === 1) {
                    currentMapData[r][c] = Math.random() < 0.6 ? 0 : 1;
                    i++;
                } else if (currentMapData[r][c] === 0) {
                    currentMapData[r][c] = Math.random() < 0.1 ? 1 : 0;
                    i++;
                }
            }
        }

        function createEnvironmentFromMapData() {
            const floorGeometry = new THREE.PlaneGeometry(200, 200);
            const floorMaterial = new THREE.MeshStandardMaterial({ color: 0x1a1a3a, roughness: 0.7, metalness: 0.3 });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.receiveShadow = true;
            scene.add(floor);

            const ceilingMaterial = new THREE.MeshStandardMaterial({ color: 0x050515, roughness: 0.9 });
            const ceiling = new THREE.Mesh(floorGeometry, ceilingMaterial);
            ceiling.rotation.x = Math.PI / 2;
            ceiling.position.y = wallSize * 1.5;
            scene.add(ceiling);

            const wallGeometry = new THREE.BoxGeometry(wallSize, wallSize * 1.5, wallSize);
            const wallTexture = createCyberWallTexture();
            const wallMaterial = new THREE.MeshStandardMaterial({ map: wallTexture, roughness: 0.6, metalness: 0.4 });

            for (let r = 0; r < currentMapData.length; r++) {
                for (let c = 0; c < currentMapData[r].length; c++) {
                    if (currentMapData[r][c] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.x = (c - currentMapData[r].length / 2 + 0.5) * wallSize;
                        wall.position.y = (wallSize * 1.5) / 2;
                        wall.position.z = (r - currentMapData.length / 2 + 0.5) * wallSize;
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        wall.userData.boundingBox = new THREE.Box3().setFromObject(wall);
                        walls.push(wall);
                        scene.add(wall);
                    }
                }
            }
        }

        function spawnEnemiesForRound(count) {
            const spawnPoints = getValidSpawnPoints(count);
            const numToSpawn = Math.min(count, spawnPoints.length);
            console.log(`Spawning ${numToSpawn} enemies for round ${currentRound}. Target: ${enemiesToKillForNextRound}, Available points: ${spawnPoints.length}`);
            for (let i = 0; i < numToSpawn; i++) {
                const pointIndex = Math.floor(Math.random() * spawnPoints.length);
                const point = spawnPoints.splice(pointIndex, 1)[0];
                spawnSingleEnemy(point.x, point.z);
            }
        }

        function getValidSpawnPoints(neededPoints) {
            const points = [];
            const playerPos = controls.getObject().position;
            const minSpawnDistSq = (wallSize * 2.5) * (wallSize * 2.5);

            for (let r = 0; r < currentMapData.length; r++) {
                for (let c = 0; c < currentMapData[r].length; c++) {
                    if (currentMapData[r][c] === 0) {
                        const x = (c - currentMapData[r].length / 2 + 0.5) * wallSize;
                        const z = (r - currentMapData.length / 2 + 0.5) * wallSize;
                        const spawnPos = new THREE.Vector3(x, playerHeight * 0.5, z);

                        if (playerPos.distanceToSquared(spawnPos) < minSpawnDistSq) {
                            continue;
                        }

                        let overlapsWithWall = false;
                        const enemyRadius = playerRadius * 0.7;
                        const enemyHeight = playerRadius * 2.2;
                        const tempEnemyCollider = new THREE.Box3().setFromCenterAndSize(
                            new THREE.Vector3(x, enemyHeight / 2, z),
                            new THREE.Vector3(enemyRadius * 2, enemyHeight, enemyRadius * 2)
                        );
                        for (const wall of walls) {
                            if (tempEnemyCollider.intersectsBox(wall.userData.boundingBox)) {
                                overlapsWithWall = true;
                                break;
                            }
                        }
                        if (!overlapsWithWall) {
                            points.push({ x, z });
                        }
                    }
                }
            }
            if (points.length < neededPoints && points.length > 0) {
                console.warn(`요청한 스폰 포인트(${neededPoints})보다 적은 수(${points.length})의 유효 지점만 찾았습니다.`);
                return points;
            } else if (points.length === 0) {
                console.error("유효한 스폰 지점을 전혀 찾을 수 없습니다! 맵 데이터 또는 로직 확인 필요. 임의 위치에 스폰합니다.");
                for(let i=0; i<neededPoints; i++){
                    points.push({x: (Math.random()-0.5) * wallSize * (currentMapData[0].length/2 - 2), z: (Math.random()-0.5) * wallSize * (currentMapData.length/2 - 2)});
                }
            }
            return points;
        }

        function createPlayerGun() {
            playerGunMesh = new THREE.Group();
            const gunBodyMaterial = new THREE.MeshStandardMaterial({ color: 0x222233, metalness: 0.7, roughness: 0.3, emissive: 0x111122, emissiveIntensity: 0.5 });
            const gunAccentMaterial = new THREE.MeshStandardMaterial({ color: 0x00ffff, metalness: 0.8, roughness: 0.2, emissive: 0x00ffff, emissiveIntensity: 0.8 });

            const barrelGeometry = new THREE.CylinderGeometry(0.03, 0.03, 0.6, 16);
            const barrel = new THREE.Mesh(barrelGeometry, gunBodyMaterial);
            barrel.position.set(0, -0.05, -0.4);
            barrel.rotation.x = Math.PI / 2;
            playerGunMesh.add(barrel);

            gunTip = new THREE.Object3D();
            gunTip.position.set(0, -0.05, -0.7);
            playerGunMesh.add(gunTip);

            const bodyGeometry = new THREE.BoxGeometry(0.1, 0.12, 0.4);
            const body = new THREE.Mesh(bodyGeometry, gunBodyMaterial);
            body.position.set(0, -0.1, 0);
            playerGunMesh.add(body);

            const stockGeometry = new THREE.BoxGeometry(0.08, 0.1, 0.3);
            const stock = new THREE.Mesh(stockGeometry, gunBodyMaterial);
            stock.position.set(0, -0.08, 0.3);
            playerGunMesh.add(stock);

            const gripGeometry = new THREE.BoxGeometry(0.06, 0.2, 0.06);
            const grip = new THREE.Mesh(gripGeometry, new THREE.MeshStandardMaterial({color: 0x111118, metalness:0.4, roughness: 0.6}));
            grip.position.set(0, -0.2, -0.05);
            grip.rotation.x = -0.2;
            playerGunMesh.add(grip);

            const lineGeo = new THREE.BoxGeometry(0.01, 0.01, 0.35);
            const line1 = new THREE.Mesh(lineGeo, gunAccentMaterial);
            line1.position.set(0.04, -0.05, -0.1);
            playerGunMesh.add(line1);
            const line2 = new THREE.Mesh(lineGeo, gunAccentMaterial);
            line2.position.set(-0.04, -0.05, -0.1);
            playerGunMesh.add(line2);

            originalGunMaterial = {
                body: gunBodyMaterial.clone(),
                accent: gunAccentMaterial.clone()
            };

            playerGunMesh.position.set(0.25, -0.3, -0.7);
            playerGunMesh.rotation.y = -0.1;
            playerGunMesh.visible = false;
            camera.add(playerGunMesh);
        }

        function createCyberWallTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const context = canvas.getContext('2d');
            context.fillStyle = '#1a1a2a';
            context.fillRect(0, 0, 128, 128);
            context.strokeStyle = '#0055aa';
            context.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                context.beginPath();
                context.moveTo(Math.random() * 128, Math.random() * 128);
                context.lineTo(Math.random() * 128, Math.random() * 128);
                context.stroke();
                if (Math.random() < 0.5) {
                    context.lineTo(Math.random() * 128, Math.random() * 128);
                    context.stroke();
                }
            }
            context.fillStyle = '#00aaff';
            for (let i = 0; i < 30; i++) {
                context.fillRect(Math.random() * 128, Math.random() * 128, 2, 2);
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 1);
            return texture;
        }

        function spawnSingleEnemy(x, z) {
            const enemyRadius = playerRadius * 0.7;
            const enemyHeight = playerRadius * 2.2;
            let enemyGeometry;
            let enemyColor = 0xff3333;
            let enemyEmissive = 0x550000;

            switch (currentRound) {
                case 1:
                    enemyGeometry = new THREE.CylinderGeometry(enemyRadius, enemyRadius, enemyHeight, 12);
                    enemyColor = 0xff3333; enemyEmissive = 0x550000;
                    break;
                case 2:
                    enemyGeometry = new THREE.BoxGeometry(enemyRadius * 1.5, enemyHeight, enemyRadius * 1.5);
                    enemyColor = 0x33ff33; enemyEmissive = 0x005500;
                    break;
                case 3:
                    enemyGeometry = new THREE.SphereGeometry(enemyRadius * 1.2, 16, 12);
                    enemyColor = 0x3333ff; enemyEmissive = 0x000055;
                    break;
                case 4:
                    enemyGeometry = new THREE.ConeGeometry(enemyRadius, enemyHeight, 16);
                    enemyColor = 0xffff33; enemyEmissive = 0x555500;
                    break;
                case 5:
                    enemyGeometry = new THREE.TorusKnotGeometry(enemyRadius * 0.8, enemyRadius * 0.3, 64, 8);
                    enemyColor = 0xff00ff; enemyEmissive = 0x550055;
                    break;
                default:
                    enemyGeometry = new THREE.CylinderGeometry(enemyRadius, enemyRadius, enemyHeight, 12);
            }

            const enemyMaterial = new THREE.MeshStandardMaterial({
                color: enemyColor,
                emissive: enemyEmissive,
                roughness: 0.4,
                metalness: 0.3
            });

            const enemy = new THREE.Mesh(enemyGeometry, enemyMaterial);
            enemy.position.set(x, enemyHeight / 2, z);
            enemy.castShadow = true;

            enemy.userData = {
                health: 80 + (currentRound - 1) * 20,
                speed: currentGlobalEnemySpeed,
                originalSpeed: currentGlobalEnemySpeed,
                boundingBox: new THREE.Box3(),
                id: `enemy_${Math.random().toString(36).substring(2,15)}`,
                shootCooldown: Math.random() * 1 + 1.5,
                shootInterval: Math.max(0.5, (2.5 - currentRound * 0.2)),
                canSeePlayer: false,
                targetPosition: new THREE.Vector3(x, enemyHeight / 2, z),
                isMovingToTarget: false,
                moveTimer: 0,
                jumpCooldown: Math.random() * 3 + 2,
                isJumping: false,
                velocityY: 0,
                originalY: enemyHeight / 2,
            };
            enemy.userData.boundingBox.setFromObject(enemy);
            enemies.push(enemy);
            scene.add(enemy);
        }

        function updatePlayerDamage() {
            const rand = Math.random() * 100;
            if (rand < 70) {
                currentPlayerDamage = Math.floor(Math.random() * 49) + 1;
            } else if (rand < 90) {
                currentPlayerDamage = Math.floor(Math.random() * 10) + 50;
            } else {
                currentPlayerDamage = Math.floor(Math.random() * 11) + 60;
            }
            playerDamageHUDElement.textContent = `데미지: ${currentPlayerDamage}`;
        }

        let prevTime = performance.now();
        function animate() {
             if (!gameRunning && (playerHealth <= 0 || currentRound > maxRounds)) {
                 if (messageBoxElement.style.display === 'flex') {
                      requestAnimationFrame(animate);
                      renderer.render(scene, camera);
                 }
                 return;
             }
             if (!gameRunning) {
                 requestAnimationFrame(animate);
                 renderer.render(scene, camera);
                 return;
             }

            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            if (time - lastDamageUpdateTime > damageUpdateInterval) {
                updatePlayerDamage();
                lastDamageUpdateTime = time;
            }

            applyPlayerGravity(delta);

            currentMoveSpeed = isSprinting ? moveSpeed * sprintMultiplier : moveSpeed;
            if (isMachineGunModeActive) {
                currentMoveSpeed *= 0.7;
            }
            if (isSlideJumpBoosting && time < slideJumpBoostEndTime) {
                currentMoveSpeed = moveSpeed + slideJumpBoost;
            } else if (isSlideJumpBoosting && time >= slideJumpBoostEndTime) {
                isSlideJumpBoosting = false;
            }

            let currentFOV = isSliding ? slideFOV : (isSprinting ? sprintFOV : defaultFOV);
            camera.fov += (currentFOV - camera.fov) * 0.1;
            camera.updateProjectionMatrix();

            const playerObject = controls.getObject();
            let intendedDeltaX = 0;
            let intendedDeltaZ = 0;
            const camDirection = new THREE.Vector3();
            camera.getWorldDirection(camDirection);
            if (!isSliding) camDirection.y = 0;
            camDirection.normalize();

            const rightDirection = new THREE.Vector3();
            // *** 올바른 외적 순서로 수정: camDirection.cross(camera.up) ***
            rightDirection.crossVectors(camDirection, camera.up).normalize();

            if (moveForward) {
                intendedDeltaX += camDirection.x * currentMoveSpeed * delta;
                intendedDeltaZ += camDirection.z * currentMoveSpeed * delta;
            }
            if (moveBackward) {
                intendedDeltaX -= camDirection.x * currentMoveSpeed * delta;
                intendedDeltaZ -= camDirection.z * currentMoveSpeed * delta;
            }
            if (moveLeft) { // A 키 (이제 실제로 왼쪽으로 이동)
                intendedDeltaX -= rightDirection.x * currentMoveSpeed * delta;
                intendedDeltaZ -= rightDirection.z * currentMoveSpeed * delta;
            }
            if (moveRight) { // D 키 (이제 실제로 오른쪽으로 이동)
                intendedDeltaX += rightDirection.x * currentMoveSpeed * delta;
                intendedDeltaZ += rightDirection.z * currentMoveSpeed * delta;
            }

            const tempPlayerPos = playerObject.position.clone();
            const prevPlayerPos = playerObject.position.clone();

            tempPlayerPos.x += intendedDeltaX;
            if (!checkWallCollision(tempPlayerPos)) {
                playerObject.position.x = tempPlayerPos.x;
            } else {
                playerObject.position.x = prevPlayerPos.x + Math.sign(intendedDeltaX) * 0.01;
            }
            tempPlayerPos.x = playerObject.position.x;

            tempPlayerPos.z += intendedDeltaZ;
            if (!checkWallCollision(tempPlayerPos)) {
                playerObject.position.z = tempPlayerPos.z;
            } else {
                 playerObject.position.z = prevPlayerPos.z + Math.sign(intendedDeltaZ) * 0.01;
            }

            playerBoundingBox.setFromCenterAndSize(
                playerObject.position,
                new THREE.Vector3(playerRadius * 2, playerHeight, playerRadius * 2)
            );

            if (isMouseDown && isMachineGunModeActive && !isReloading && gameRunning) {
                if (time - lastMachineGunShootTime > machineGunShootInterval) {
                    shoot();
                    lastMachineGunShootTime = time;
                }
            }

            updateEnemies(delta, time);
            updateEnemyBullets(delta);
            updatePlayerBullets(delta);
            updateMuzzleSmoke(delta);
            updateImpactSparks(delta);
            updateExplosions(delta);
            updateMachineGunMode(time);
            updateShield(time);
            updateElapsedTime(time);
            updateSlideJumpInfo(time);

            prevTime = time;
            renderer.render(scene, camera);
        }

        function applyPlayerGravity(delta) {
            const playerObject = controls.getObject();
            const targetPlayerY = isSliding ? slideHeight : playerHeight;

            if (!canPlayerJump || playerObject.position.y > targetPlayerY) {
                playerVelocityY += gravity * delta;
                playerObject.position.y += playerVelocityY * delta;

                if (playerObject.position.y <= targetPlayerY) {
                    playerObject.position.y = targetPlayerY;
                    playerVelocityY = 0;
                    if (!isSliding) {
                         canPlayerJump = true;
                         if (landSound && audioContextStarted && Math.abs(playerVelocityY) < 0.1) {
                             landSound.triggerAttackRelease("C2", "8n");
                         }
                    }
                }
            } else if (playerObject.position.y < targetPlayerY) {
                 playerObject.position.y = targetPlayerY;
                 playerVelocityY = 0;
                 canPlayerJump = true;
            }
        }

        function checkWallCollision(proposedPosition, objectRadius = playerRadius) {
            const objectHeight = isSliding ? slideHeight : ((objectRadius === playerRadius) ? playerHeight : objectRadius * 2.2);
            const objectCenterY = isSliding ? slideHeight / 2 : ((objectRadius === playerRadius) ? proposedPosition.y - playerHeight/2 + objectHeight/2 : proposedPosition.y);

            const objectCollider = new THREE.Box3().setFromCenterAndSize(
                new THREE.Vector3(proposedPosition.x, objectCenterY, proposedPosition.z),
                new THREE.Vector3(objectRadius * 2, objectHeight, objectRadius * 2)
            );

            for (const wall of walls) {
                if (objectCollider.intersectsBox(wall.userData.boundingBox)) {
                    return true;
                }
            }
            return false;
        }

        function updateEnemies(delta, time) {
            const playerPos = controls.getObject().position;
            enemies.forEach((enemy, index) => {
                if (!enemy.userData || enemy.userData.health <= 0) return;

                const enemyPos = enemy.position;
                const directionToPlayer = playerPos.clone().sub(enemyPos);
                const distanceToPlayerSq = directionToPlayer.lengthSq();
                const distanceToPlayer = Math.sqrt(distanceToPlayerSq);
                directionToPlayer.normalize();

                const raycaster = new THREE.Raycaster(
                    new THREE.Vector3(enemyPos.x, playerHeight * 0.8, enemyPos.z),
                    directionToPlayer
                );
                const intersects = raycaster.intersectObjects(walls, false);
                enemy.userData.canSeePlayer = false;
                if (intersects.length === 0 || intersects[0].distance > distanceToPlayer - playerRadius) {
                    if (distanceToPlayer < 30) {
                         enemy.userData.canSeePlayer = true;
                    }
                }

                enemy.userData.jumpCooldown -= delta;
                if (!enemy.userData.isJumping && enemy.userData.jumpCooldown <= 0 && Math.random() < 0.01) {
                    enemy.userData.isJumping = true;
                    enemy.userData.velocityY = playerJumpForce * 0.7;
                    enemy.userData.jumpCooldown = Math.random() * 4 + 3;
                }
                if (enemy.userData.isJumping) {
                    enemy.userData.velocityY += gravity * delta * 0.8;
                    enemy.position.y += enemy.userData.velocityY * delta;
                    if (enemy.position.y <= enemy.userData.originalY) {
                        enemy.position.y = enemy.userData.originalY;
                        enemy.userData.isJumping = false;
                        enemy.userData.velocityY = 0;
                    }
                }

                if (enemy.userData.canSeePlayer) {
                    const targetRotation = Math.atan2(directionToPlayer.x, directionToPlayer.z);
                    enemy.rotation.y += (targetRotation - enemy.rotation.y) * 0.1;

                    if (distanceToPlayer > wallSize * 1.5) {
                        const enemyMoveSpeed = enemy.userData.speed * delta;
                        const potentialMove = directionToPlayer.clone().multiplyScalar(enemyMoveSpeed);
                        const oldPos = enemy.position.clone();
                        let canMoveX = true;
                        let canMoveZ = true;
                        const enemyRadiusForCollision = playerRadius * 0.7;

                        enemy.position.x += potentialMove.x;
                        if(checkWallCollision(enemy.position, enemyRadiusForCollision)) canMoveX = false;
                        if (!canMoveX) enemy.position.x = oldPos.x;

                        enemy.position.z += potentialMove.z;
                        if(checkWallCollision(enemy.position, enemyRadiusForCollision)) canMoveZ = false;
                        if (!canMoveZ) enemy.position.z = oldPos.z;
                    }

                    enemy.userData.shootCooldown -= delta;
                    if (enemy.userData.shootCooldown <= 0 && distanceToPlayer < 25) {
                        fireEnemyBullet(enemy, directionToPlayer.clone());
                        enemy.userData.shootCooldown = enemy.userData.shootInterval;
                    }
                } else {
                    enemy.userData.moveTimer -= delta;
                    if (enemy.userData.moveTimer <= 0) {
                        const randomAngle = Math.random() * Math.PI * 2;
                        const randomDist = Math.random() * wallSize * 2 + wallSize;
                        enemy.userData.targetPosition.set(
                            enemyPos.x + Math.sin(randomAngle) * randomDist,
                            enemy.userData.originalY,
                            enemyPos.z + Math.cos(randomAngle) * randomDist
                        );
                        enemy.userData.isMovingToTarget = true;
                        enemy.userData.moveTimer = Math.random() * 3 + 2;
                    }

                    if (enemy.userData.isMovingToTarget) {
                        const directionToTarget = enemy.userData.targetPosition.clone().sub(enemyPos).normalize();
                        const distanceToTarget = enemy.userData.targetPosition.distanceTo(enemyPos);
                        if (distanceToTarget > 0.5) {
                            const enemyMoveSpeed = enemy.userData.speed * 0.7 * delta;
                            const potentialMove = directionToTarget.multiplyScalar(enemyMoveSpeed);
                            const oldPos = enemy.position.clone();
                            let canMoveX = true;
                            let canMoveZ = true;
                            const enemyRadiusForCollision = playerRadius * 0.7;

                            enemy.position.x += potentialMove.x;
                            if(checkWallCollision(enemy.position, enemyRadiusForCollision)) canMoveX = false;
                            if (!canMoveX) enemy.position.x = oldPos.x;

                            enemy.position.z += potentialMove.z;
                            if(checkWallCollision(enemy.position, enemyRadiusForCollision)) canMoveZ = false;
                            if (!canMoveZ) enemy.position.z = oldPos.z;

                            const targetRotation = Math.atan2(directionToTarget.x, directionToTarget.z);
                            enemy.rotation.y += (targetRotation - enemy.rotation.y) * 0.05;
                        } else {
                            enemy.userData.isMovingToTarget = false;
                        }
                    }
                }
                enemy.userData.boundingBox.setFromObject(enemy);

                const collisionDistance = playerRadius + (playerRadius * 0.7);
                if (distanceToPlayer < collisionDistance && !enemy.userData.isJumping) {
                    takeDamage(5);
                    const knockbackDirection = playerPos.clone().sub(enemyPos).normalize();
                    controls.getObject().position.addScaledVector(knockbackDirection, 0.2);
                    enemy.position.addScaledVector(knockbackDirection.negate(), 0.3);
                }
            });
        }

        function fireEnemyBullet(enemy, direction) {
            if (enemyShootSound && audioContextStarted) {
                enemyShootSound.triggerAttackRelease("C3", "0.05").catch(e => console.error("적 발사음 재생 오류:", e));
            }
            const bulletGeometry = new THREE.SphereGeometry(0.15, 8, 8);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa00 });
            const bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);
            const spreadAngle = Math.PI / 24;
            direction.applyAxisAngle(new THREE.Vector3(0,1,0), (Math.random() - 0.5) * spreadAngle);
            direction.applyAxisAngle(new THREE.Vector3(1,0,0), (Math.random() - 0.5) * spreadAngle);

            const bulletOffset = direction.clone().multiplyScalar(playerRadius * 1.0);
            bullet.position.copy(enemy.position).add(bulletOffset);
            bullet.position.y = enemy.position.y;

            let maxDamageForRound = 5;
            if (currentRound > 1) {
                for (let i = 0; i < currentRound - 1; i++) {
                    maxDamageForRound = Math.floor(maxDamageForRound * 1.3);
                }
            }
            maxDamageForRound = Math.max(1, maxDamageForRound);

            bullet.userData = {
                velocity: direction.normalize().multiplyScalar(baseEnemyBulletSpeed),
                damage: Math.max(1, Math.floor(Math.random() * maxDamageForRound) + 1),
                spawnTime: performance.now()
            };
            enemyBullets.push(bullet);
            scene.add(bullet);
        }

        function updateEnemyBullets(delta) {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.position.addScaledVector(bullet.userData.velocity, delta);

                if (performance.now() - bullet.userData.spawnTime > 5000) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                    continue;
                }

                const bulletSphere = new THREE.Sphere(bullet.position, 0.15);
                if (playerBoundingBox.intersectsSphere(bulletSphere)) {
                    takeDamage(bullet.userData.damage);
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                    continue;
                }

                for (const wall of walls) {
                    if (wall.userData.boundingBox.intersectsSphere(bulletSphere)) {
                        scene.remove(bullet);
                        enemyBullets.splice(i, 1);
                        i = -1;
                        break;
                    }
                }
                 if (i === -1) continue;
            }
        }

        function shoot() {
            if (isReloading || !gameRunning) return;

            let damageToDeal;

            if (isMachineGunModeActive) {
                if (machineGunCurrentAmmo <= 0) {
                    isMachineGunModeActive = false;
                    updateHUD();
                    if (playerAmmo < maxPlayerAmmo) handleReload();
                    return;
                }
                machineGunCurrentAmmo--;
                damageToDeal = currentMachineGunDamage;
            } else {
                if (playerAmmo <= 0) {
                    handleReload();
                    return;
                }
                playerAmmo--;
                damageToDeal = currentPlayerDamage;
            }

            updateHUD();
            if (shootSound && audioContextStarted) {
                shootSound.triggerAttackRelease(0.05).catch(e => console.error("플레이어 발사음 재생 오류:", e));
            }

            const gunTipWorldPosition = new THREE.Vector3();
            const cameraDirection = new THREE.Vector3();
            camera.getWorldDirection(cameraDirection);
            gunTip.getWorldPosition(gunTipWorldPosition);

            createMuzzleSmoke(gunTipWorldPosition, isMachineGunModeActive);

            const bulletGeometry = new THREE.SphereGeometry(0.08, 6, 6);
            const bulletMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff, emissiveIntensity: 1.5 });
            const playerBullet = new THREE.Mesh(bulletGeometry, bulletMaterial);

            playerBullet.position.copy(gunTipWorldPosition);
            playerBullet.userData = {
                velocity: cameraDirection.clone().multiplyScalar(PLAYER_BULLET_SPEED),
                spawnTime: performance.now(),
                damage: damageToDeal
            };
            playerBullets.push(playerBullet);
            scene.add(playerBullet);
        }

        function updatePlayerBullets(delta) {
            for (let i = playerBullets.length - 1; i >= 0; i--) {
                const bullet = playerBullets[i];
                bullet.position.addScaledVector(bullet.userData.velocity, delta);

                if (performance.now() - bullet.userData.spawnTime > 2000) {
                    scene.remove(bullet);
                    playerBullets.splice(i, 1);
                    continue;
                }

                const bulletSphere = new THREE.Sphere(bullet.position, 0.08);
                for (const wall of walls) {
                    if (wall.userData.boundingBox.intersectsSphere(bulletSphere)) {
                        createImpactSpark(bullet.position);
                        if (ricochetSound && audioContextStarted) ricochetSound.triggerAttackRelease().catch(e => console.error("도탄음 재생 오류:", e));
                        scene.remove(bullet);
                        playerBullets.splice(i, 1);
                        i = -1;
                        break;
                    }
                }
                if (i === -1) continue;

                for (const enemy of enemies) {
                    if (enemy.userData.health > 0 && enemy.userData.boundingBox.intersectsSphere(bulletSphere)) {
                        let damageDealt = bullet.userData.damage;
                        let scoreMultiplier = 1;

                        if (damageDealt >= 60 && !isMachineGunModeActive) {
                            showSuperCriticalHitMessage();
                            damageDealt = enemy.userData.health;
                            scoreMultiplier = 2;
                        } else if (damageDealt >= 50 && !isMachineGunModeActive) {
                            showCriticalHitMessage();
                        }

                        enemy.userData.health -= damageDealt;
                        if (enemyHitSound && audioContextStarted) {
                             enemyHitSound.triggerAttackRelease("C4", "8n").catch(e => console.error("적 피격음 재생 오류:", e));
                        }

                        if (enemy.userData.health <= 0) {
                            createExplosionEffect(enemy.position);
                            if (enemyDieSound && audioContextStarted) enemyDieSound.triggerAttackRelease("0.3");
                            scene.remove(enemy);
                            const enemyIndex = enemies.findIndex(e => e.userData.id === enemy.userData.id);
                            if (enemyIndex > -1) enemies.splice(enemyIndex, 1);

                            score += (10 * scoreMultiplier);
                            killedEnemiesThisRound++;
                            totalKilledEnemies++;
                            updateHUD();

                            if (killedEnemiesThisRound >= enemiesToKillForNextRound) {
                                if (currentRound < maxRounds) {
                                    showRoundTransitionMessage(`${currentRound} 라운드 성공!`);
                                    if(roundSuccessSound && audioContextStarted) roundSuccessSound.triggerAttackRelease("G5", "4n");
                                    gameRunning = false;
                                    setTimeout(() => {
                                        currentRound++;
                                        startNewRound();
                                        if (controls.isLocked) gameRunning = true;
                                    }, 2000);
                                } else {
                                    gameClear();
                                }
                            } else {
                                const maxAdditionalSpawns = 6;
                                const currentEnemyCount = enemies.filter(e => e.userData.health > 0).length;
                                const maxAllowedEnemiesThisRound = enemiesToKillForNextRound + 10;
                                const enemiesToActuallySpawn = Math.min(maxAdditionalSpawns, maxAllowedEnemiesThisRound - currentEnemyCount, 1);
                                if (enemiesToActuallySpawn > 0) {
                                    spawnEnemiesForRound(enemiesToActuallySpawn);
                                }
                            }
                        } else {
                             enemy.material.color.setHex(0xffffff);
                             setTimeout(() => {
                                 if(enemy.material && enemy.userData.health > 0) {
                                    let originalColor = 0xff3333;
                                    switch (currentRound) {
                                        case 1: originalColor = 0xff3333; break;
                                        case 2: originalColor = 0x33ff33; break;
                                        case 3: originalColor = 0x3333ff; break;
                                        case 4: originalColor = 0xffff33; break;
                                        case 5: originalColor = 0xff00ff; break;
                                    }
                                    enemy.material.color.setHex(originalColor);
                                 }
                             }, 100);
                        }
                        scene.remove(bullet);
                        playerBullets.splice(i, 1);
                        i = -1;
                        break;
                    }
                }
                 if (i === -1) continue;
            }
        }

        function showCriticalHitMessage() {
            criticalHitMessageElement.style.display = 'block';
            criticalHitMessageElement.style.animation = 'none';
            criticalHitMessageElement.offsetHeight;
            criticalHitMessageElement.style.animation = 'criticalHitAnimation 0.7s ease-out forwards';
            setTimeout(() => {
                criticalHitMessageElement.style.display = 'none';
            }, 700);
        }
        function showSuperCriticalHitMessage() {
            superCriticalHitMessageElement.style.display = 'block';
            superCriticalHitMessageElement.style.animation = 'none';
            superCriticalHitMessageElement.offsetHeight;
            superCriticalHitMessageElement.style.animation = 'superCriticalHitAnimation 1s ease-out forwards';
            setTimeout(() => {
                superCriticalHitMessageElement.style.display = 'none';
            }, 1000);
        }
        function showRoundTransitionMessage(message) {
            roundTransitionMessageElement.textContent = message;
            roundTransitionMessageElement.style.display = 'block';
            setTimeout(() => {
                roundTransitionMessageElement.style.display = 'none';
            }, 1800);
        }
        function showShieldStatusMessage(message, duration = 1000) {
            shieldStatusMessageElement.textContent = message;
            shieldStatusMessageElement.style.color = "#40C4FF";
            shieldStatusMessageElement.style.display = 'block';
            setTimeout(() => {
                shieldStatusMessageElement.style.display = 'none';
            }, duration);
        }
        function showMachineGunStatusMessage(message, duration = 1500) {
            machineGunStatusMessageElement.textContent = message;
            machineGunStatusMessageElement.style.color = "#FF00FF";
            machineGunStatusMessageElement.style.display = 'block';
            setTimeout(() => {
                machineGunStatusMessageElement.style.display = 'none';
            }, duration);
        }

        function createMuzzleSmoke(position, isMachineGun = false) {
            const smokeColor = isMachineGun ? 0xff8800 : 0x00ffff;
            const smokeSize = isMachineGun ? 0.3 : 0.2;
            const smokeLife = isMachineGun ? 0.5 : 0.4;
            const particleCount = isMachineGun ? 10 : 7;
            const smokeMaterial = new THREE.PointsMaterial({ color: smokeColor, size: smokeSize, transparent: true, opacity: 0.6, sizeAttenuation: true, blending: THREE.AdditiveBlending });
            for (let i = 0; i < particleCount; i++) {
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3));
                const particle = new THREE.Points(particleGeometry, smokeMaterial.clone());
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3( (Math.random() - 0.5) * 0.6, (Math.random() - 0.5) * 0.6, (Math.random() - 0.5) * 0.6 ).multiplyScalar(isMachineGun ? 0.4 : 0.3),
                    life: smokeLife * (0.8 + Math.random() * 0.4)
                };
                muzzleSmokeParticles.push(particle);
                scene.add(particle);
            }
        }
        function updateMuzzleSmoke(delta) {
            for (let i = muzzleSmokeParticles.length - 1; i >= 0; i--) {
                const particle = muzzleSmokeParticles[i];
                particle.userData.life -= delta;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    muzzleSmokeParticles.splice(i, 1);
                } else {
                    particle.position.addScaledVector(particle.userData.velocity, delta);
                    particle.material.opacity = particle.userData.life * 2.5;
                    particle.material.size = particle.userData.life * 0.5;
                }
            }
        }
        function createImpactSpark(position) {
            const sparkMaterial = new THREE.PointsMaterial({ color: 0x00ffff, size: 0.25, transparent: true, opacity: 0.9, sizeAttenuation: true, blending: THREE.AdditiveBlending });
            for (let i = 0; i < 10; i++) {
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3));
                const particle = new THREE.Points(particleGeometry, sparkMaterial.clone());
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3( (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5) ).normalize().multiplyScalar(Math.random() * 4 + 3),
                    life: 0.25 * (0.8 + Math.random() * 0.4)
                };
                impactSparks.push(particle);
                scene.add(particle);
            }
        }
        function updateImpactSparks(delta) {
            for (let i = impactSparks.length - 1; i >= 0; i--) {
                const particle = impactSparks[i];
                particle.userData.life -= delta;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    impactSparks.splice(i, 1);
                } else {
                    particle.position.addScaledVector(particle.userData.velocity, delta);
                    particle.userData.velocity.y -= 9.8 * delta * 0.1;
                    particle.material.opacity = particle.userData.life * 4;
                    particle.material.size = particle.userData.life * 0.6;
                }
            }
        }
        function createExplosionEffect(position) {
            const explosionMaterial = new THREE.PointsMaterial({ color: 0xff00ff, size: 0.6, transparent: true, opacity: 0.9, sizeAttenuation: true, blending: THREE.AdditiveBlending });
            for (let i = 0; i < 25; i++) {
                const particleGeometry = new THREE.BufferGeometry();
                particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0], 3));
                const particle = new THREE.Points(particleGeometry, explosionMaterial.clone());
                particle.position.copy(position);
                particle.userData = {
                    velocity: new THREE.Vector3( (Math.random() - 0.5), (Math.random() - 0.5), (Math.random() - 0.5) ).normalize().multiplyScalar(Math.random() * 6 + 4),
                    life: 0.7 * (0.7 + Math.random() * 0.6)
                };
                explosionParticles.push(particle);
                scene.add(particle);
            }
        }
        function updateExplosions(delta) {
            for (let i = explosionParticles.length - 1; i >= 0; i--) {
                const particle = explosionParticles[i];
                particle.userData.life -= delta;
                if (particle.userData.life <= 0) {
                    scene.remove(particle);
                    explosionParticles.splice(i, 1);
                } else {
                    particle.position.addScaledVector(particle.userData.velocity, delta);
                    particle.material.opacity = particle.userData.life * 1.3;
                    particle.material.size = particle.userData.life * 0.9;
                }
            }
        }

        function takeDamage(amount) {
            if (!gameRunning || playerHealth <=0) return;
            let actualDamage = amount;
            if (isShieldActive && shieldHealth > 0) {
                if (shieldHealth >= amount) {
                    shieldHealth -= amount;
                    actualDamage = 0;
                } else {
                    actualDamage = amount - shieldHealth;
                    shieldHealth = 0;
                }
                if (shieldHealth <= 0) {
                    isShieldActive = false;
                    if(shieldMesh) shieldMesh.visible = false;
                    if(shieldBreakSound && audioContextStarted) shieldBreakSound.triggerAttackRelease("0.2");
                    shieldCooldownEndTime = performance.now() + shieldCooldown;
                }
                updateHUD();
                if (actualDamage === 0) return;
            }

            playerHealth -= actualDamage;
            if (playerHealth < 0) playerHealth = 0;
            if (playerHurtSound && audioContextStarted) {
                playerHurtSound.triggerAttackRelease("0.2").catch(e => console.error("플레이어 피격음 재생 오류:", e));
            }
            updateHUD();
            document.body.style.transition = 'background-color 0.05s';
            document.body.style.backgroundColor = 'rgba(200,0,0,0.4)';
            setTimeout(() => {
                document.body.style.backgroundColor = '#0a0a1a';
            }, 50);
            if (playerHealth <= 0) {
                gameOver("사망했습니다! 게임 오버.");
            }
        }

        function updateHUD() {
            scoreElement.textContent = `점수: ${score}`;
            healthElement.textContent = `체력: ${playerHealth} / ${maxPlayerHealth}`;

            if (isMachineGunModeActive) {
                ammoElement.textContent = `머신건: ${machineGunCurrentAmmo} / ${machineGunTotalMaxAmmo}`;
            } else {
                ammoElement.textContent = `탄약: ${playerAmmo} / ${maxPlayerAmmo}`;
            }

            playerDamageHUDElement.textContent = `데미지: ${currentPlayerDamage}`;
            roundInfoElement.innerHTML = `라운드: ${currentRound > maxRounds ? maxRounds : currentRound} / ${maxRounds}<br>처치 목표: ${killedEnemiesThisRound} / ${enemiesToKillForNextRound}`;

            const now = performance.now();
            if (machineGunCooldownEndTime > now) {
                const remainingCooldown = Math.ceil((machineGunCooldownEndTime - now) / 1000);
                machineGunInfoElement.innerHTML = `머신건: 쿨 (${remainingCooldown}초)<br>탄약: -`;
            } else if (isMachineGunModeActive) {
                const remainingDuration = Math.ceil((machineGunModeEndTime - now) / 1000);
                machineGunInfoElement.innerHTML = `머신건: 활성 (${remainingDuration}초)<br>탄약: ${machineGunCurrentAmmo}`;
            } else {
                machineGunInfoElement.innerHTML = `머신건: 준비 (H)<br>탄약: -`;
            }

            if (shieldCooldownEndTime > now) {
                const remainingCooldown = Math.ceil((shieldCooldownEndTime - now) / 1000);
                 shieldInfoElement.innerHTML = `방패: 쿨 (${remainingCooldown}초)<br>내구도: ${maxShieldHealth}`;
            } else if (isShieldActive) {
                shieldInfoElement.innerHTML = `방패: 활성<br>내구도: ${shieldHealth} / ${maxShieldHealth}`;
            } else {
                shieldInfoElement.innerHTML = `방패: 준비 (우클릭)<br>내구도: ${maxShieldHealth}`;
            }
        }

        function updateElapsedTime(time) {
            if (!gameStartTime) return;
            const elapsedSecondsTotal = Math.floor((time - gameStartTime) / 1000);
            const minutes = Math.floor(elapsedSecondsTotal / 60);
            const seconds = elapsedSecondsTotal % 60;
            elapsedTimeHUDElement.textContent = `시간: ${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        function handleReload() {
            if (isReloading) return;
            if (isMachineGunModeActive) return;
            if (playerAmmo === maxPlayerAmmo) return;

            isReloading = true;
            if (reloadSound && audioContextStarted) {
                reloadSound.triggerAttackRelease("C2", "0.1").catch(e => console.error("재장전 소리 재생 오류:", e));
            }
            let reloadTime = 1200;
            if (playerAmmo > 0 && playerAmmo < maxPlayerAmmo) {
                tacticalReloadMessageElement.style.display = 'block';
                let blinkCount = 0;
                const blinkInterval = setInterval(() => {
                    tacticalReloadMessageElement.style.visibility = (tacticalReloadMessageElement.style.visibility === 'hidden' ? 'visible' : 'hidden');
                    blinkCount++;
                    if (blinkCount >= 4) {
                        clearInterval(blinkInterval);
                        tacticalReloadMessageElement.style.display = 'none';
                        tacticalReloadMessageElement.style.visibility = 'visible';
                    }
                }, 125);
                reloadTime = 500;
                 setTimeout(() => {
                    playerAmmo = maxPlayerAmmo;
                    isReloading = false;
                    updateHUD();
                }, reloadTime);
            } else {
                 setTimeout(() => {
                    playerAmmo = maxPlayerAmmo;
                    isReloading = false;
                    updateHUD();
                }, reloadTime);
            }
        }

        function activateMachineGunMode() {
            const now = performance.now();
            if (isMachineGunModeActive || machineGunCooldownEndTime > now) return;

            isMachineGunModeActive = true;
            machineGunModeEndTime = now + machineGunModeDuration;
            machineGunCurrentAmmo = machineGunTotalMaxAmmo;
            machineGunCooldownEndTime = now + machineGunCooldown + machineGunModeDuration;
            showMachineGunStatusMessage("MACHINE GUN MODE!", 2000);
            if (machineGunActivateSound && audioContextStarted) {
                machineGunActivateSound.triggerAttackRelease("E4", "0.2");
            }
            if (playerGunMesh && originalGunMaterial) {
                playerGunMesh.traverse((child) => {
                    if (child.isMesh) {
                        if (child.material.color.equals(originalGunMaterial.body.color)) {
                            child.material = new THREE.MeshStandardMaterial({ color: 0xAA00AA, metalness: 0.8, roughness: 0.2, emissive: 0x770077, emissiveIntensity: 0.9 });
                        } else if (child.material.color.equals(originalGunMaterial.accent.color)) {
                            child.material = new THREE.MeshStandardMaterial({ color: 0xFF00FF, metalness: 0.9, roughness: 0.1, emissive: 0xFF00FF, emissiveIntensity: 1.2 });
                        }
                    }
                });
            }
            updateHUD();
        }

        function updateMachineGunMode(time) {
            if (isMachineGunModeActive && time >= machineGunModeEndTime) {
                isMachineGunModeActive = false;
                if (playerGunMesh && originalGunMaterial) {
                    playerGunMesh.traverse((child) => {
                        if (child.isMesh) {
                             if (child.material.color.getHex() === 0xAA00AA) {
                                child.material = originalGunMaterial.body.clone();
                            } else if (child.material.color.getHex() === 0xFF00FF) {
                                child.material = originalGunMaterial.accent.clone();
                            }
                        }
                    });
                }
                updateHUD();
            }
            if (!isMachineGunModeActive && machineGunCooldownEndTime > time && time % 1000 < 50) {
                 updateHUD();
            }
        }

        function createShieldMesh() {
            const shieldShape = new THREE.Shape();
            const radius = playerRadius * 1.2;
            const sides = 6;
            shieldShape.moveTo(radius * Math.cos(0), radius * Math.sin(0));
            for (let i = 1; i <= sides; i++) {
                shieldShape.lineTo(radius * Math.cos(i * 2 * Math.PI / sides), radius * Math.sin(i * 2 * Math.PI / sides));
            }
            const shieldGeometry = new THREE.ShapeGeometry(shieldShape);
            const shieldMaterial = new THREE.MeshBasicMaterial({ color: 0x40C4FF, transparent: true, opacity: 0.3, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, wireframe: true });
            shieldMesh = new THREE.Mesh(shieldGeometry, shieldMaterial);
            shieldMesh.position.set(0, 0, -playerRadius * 1.2);
            shieldMesh.scale.set(1.5, 2, 1);
            shieldMesh.visible = false;
            camera.add(shieldMesh);
        }

        function activateShield() {
            const now = performance.now();
            if (isShieldActive || shieldCooldownEndTime > now) return;

            isShieldActive = true;
            shieldHealth = maxShieldHealth;
            if (shieldMesh) shieldMesh.visible = true;
            if (shieldActivateSound && audioContextStarted) shieldActivateSound.triggerAttackRelease("A4", "0.1");
            showShieldStatusMessage("SHIELD ACTIVATED!", 1000);
            updateHUD();
        }

        function deactivateShield() {
            if (!isShieldActive) return;
            isShieldActive = false;
            if (shieldMesh) shieldMesh.visible = false;
            shieldCooldownEndTime = performance.now() + shieldCooldown;
            updateHUD();
        }

        function updateShield(time) {
            if (isShieldActive && shieldHealth <= 0) {
                isShieldActive = false;
                if (shieldMesh) shieldMesh.visible = false;
                if (shieldBreakSound && audioContextStarted) shieldBreakSound.triggerAttackRelease("0.2");
                shieldCooldownEndTime = time + shieldCooldown;
                 updateHUD();
            }
            if (shieldMesh) {
                shieldMesh.material.opacity = isShieldActive ? 0.1 + (shieldHealth / maxShieldHealth) * 0.5 : 0;
                if (isShieldActive) {
                    shieldMesh.rotation.z += 0.05;
                }
            }
            if (shieldCooldownEndTime > time && time % 1000 < 50) {
                 updateHUD();
            }
        }

        function updateSlideJumpInfo(time) {
            const now = performance.now();
            if (slideJumpCooldownEndTime > now) {
                const remainingCooldown = ((slideJumpCooldownEndTime - now) / 1000).toFixed(1);
                slideJumpInfoElement.innerHTML = `슬라이딩 점프: 쿨 (${remainingCooldown}초)`;
            } else {
                 slideJumpInfoElement.innerHTML = `슬라이딩 점프: 가능`;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyD': moveRight = true; break;
                case 'KeyR': if(gameRunning) handleReload(); break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    if (gameRunning && !isSprinting && !isSliding) {
                        isSprinting = true;
                        if (sprintWindSound && audioContextStarted) sprintWindSound.triggerAttackRelease("0.1");
                    }
                    break;
                case 'Space':
                    if (gameRunning && canPlayerJump) {
                        if (isSliding && performance.now() > slideJumpCooldownEndTime) {
                            canPlayerJump = false;
                            playerVelocityY = playerJumpForce * 1.2;
                            isSlideJumpBoosting = true;
                            slideJumpBoostEndTime = performance.now() + slideJumpBoostDuration;
                            if (slideSound && audioContextStarted) slideSound.triggerAttackRelease("C3", "0.1s");
                            slideJumpCooldownEndTime = performance.now() + slideJumpCooldownDuration;
                            isSliding = false;
                        } else if (!isSliding) {
                            canPlayerJump = false;
                            playerVelocityY = playerJumpForce;
                            if (jumpSound && audioContextStarted) jumpSound.triggerAttackRelease("C5", "8n");
                        }
                         updateSlideJumpInfo(performance.now());
                    }
                    break;
                case 'KeyH':
                    if (gameRunning) activateMachineGunMode();
                    break;
                case 'KeyC':
                    if (gameRunning && !isSprinting && canPlayerJump && !isSliding) {
                        isSliding = true;
                        if (slideSound && audioContextStarted) slideSound.triggerAttackRelease("A2", "0.2s");
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyD': moveRight = false; break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    isSprinting = false;
                    if (sprintWindSound && sprintWindSound.state === "started" && audioContextStarted) sprintWindSound.stop();
                    break;
                case 'KeyC':
                    isSliding = false;
                    break;
            }
        }

        function resetGameFull() {
            console.log("Resetting game fully...");
            currentRound = 1;
            maxPlayerHealth = 100;
            enemiesToKillForNextRound = 20;
            totalKilledEnemies = 0;
            score = 0;
            gameStartTime = 0;
            machineGunCooldownEndTime = 0;
            shieldCooldownEndTime = 0;
            slideJumpCooldownEndTime = 0;
            maxShieldHealth = baseMaxShieldHealth;
            currentMachineGunDamage = baseMachineGunDamage;

            resetGameRound();
            messageTextElement.textContent = "사이버펑크 슈터";
            startButton.textContent = "게임 시작";
            messageBoxElement.style.display = 'flex';

            if (Tone.Transport.state === "started" && audioContextStarted) {
                 Tone.Transport.stop();
            }
            console.log("Full reset complete.");
        }

        function resetGameRound() {
            console.log("Resetting round state...");
            isReloading = false;
            isMachineGunModeActive = false;
            isShieldActive = false;
            if(shieldMesh) shieldMesh.visible = false;
            playerAmmo = maxPlayerAmmo;
            machineGunCurrentAmmo = 0;

            tacticalReloadMessageElement.style.display = 'none';
            criticalHitMessageElement.style.display = 'none';
            superCriticalHitMessageElement.style.display = 'none';
            roundTransitionMessageElement.style.display = 'none';
            shieldStatusMessageElement.style.display = 'none';
            machineGunStatusMessageElement.style.display = 'none';

            updatePlayerDamage();

            walls.forEach(wall => scene.remove(wall)); walls = [];
            enemies.forEach(enemy => scene.remove(enemy)); enemies = [];
            enemyBullets.forEach(bullet => scene.remove(bullet)); enemyBullets = [];
            playerBullets.forEach(bullet => scene.remove(bullet)); playerBullets = [];
            muzzleSmokeParticles.forEach(p => scene.remove(p)); muzzleSmokeParticles = [];
            impactSparks.forEach(p => scene.remove(p)); impactSparks = [];
            explosionParticles.forEach(p => scene.remove(p)); explosionParticles = [];

            const startPos = findStartPosition();
            if (controls && controls.getObject()) {
                controls.getObject().position.set(startPos.x, playerHeight, startPos.z);
                controls.getObject().rotation.set(0,0,0);
                if(camera) {
                     camera.rotation.set(0,0,0);
                     camera.fov = defaultFOV;
                     camera.updateProjectionMatrix();
                }
            }
            updateHUD();
            console.log("Round reset complete.");
        }

        function gameClear() {
            gameRunning = false;
            controls.unlock();
            const playTimeSeconds = gameStartTime ? Math.floor((performance.now() - gameStartTime) / 1000) : 0;
            const minutes = Math.floor(playTimeSeconds / 60);
            const seconds = playTimeSeconds % 60;
            messageTextElement.innerHTML = `생존! 모든 라운드 클리어!<br>총 처치 수: ${totalKilledEnemies}<br>플레이 시간: ${minutes}분 ${seconds}초<br>최종 점수: ${score}`;
            startButton.textContent = "다시 도전";
            messageBoxElement.style.display = 'flex';
            criticalHitMessageElement.style.display = 'none';
            superCriticalHitMessageElement.style.display = 'none';
            tacticalReloadMessageElement.style.display = 'none';
            if(playerGunMesh) playerGunMesh.visible = false;
            if(shieldMesh) shieldMesh.visible = false;
            crosshairElement.style.display = 'none';
            if (Tone.Transport.state === "started" && audioContextStarted) Tone.Transport.stop();
            if(gameClearSound && audioContextStarted) gameClearSound.triggerAttackRelease("C4", "1n");
            currentRound = maxRounds + 1;
        }

        function gameOver(message) {
            gameRunning = false;
            controls.unlock();
            messageTextElement.textContent = message + ` (라운드 ${currentRound}, 점수: ${score})`;
            startButton.textContent = "다시 플레이";
            messageBoxElement.style.display = 'flex';
            crosshairElement.style.display = 'none';
            if(playerGunMesh) playerGunMesh.visible = false;
            if(shieldMesh) shieldMesh.visible = false;
            if (Tone.Transport.state === "started" && audioContextStarted) {
                 Tone.Transport.stop();
            }
        }
        init();
    </script>
    </body>
</html>
